# 第 5 次作业 - 解析

## 重要知识点总结

### 局部性原理

判断自己是否理解了什么是局部性原理，很简单：能不能用大白话把时间局部性和空间局部性解释出来。
* 时间局部性：相同的数据很快会被再次访问
* 空间局部性：附近的数据很快会被访问

个人认为，将局部性分成时间 (temporal) 局部性和空间 (spatial) 局部性，具有一定的误导性。因为
* 时间局部性的定义中也涉及**空间** (**same location/address** will presumably be accessed soon)
* 空间局部性的定义中也涉及**时间** (nearby locations will presumably be accessed **soon**)

因此，不必教条地理解 temporal 和 spatial 这两个词。

## 书后习题 5.1

### 第 1 小问

16 字节的 cache 块中可以存放 $\frac{16}{\frac{32}{8}} = \frac{16 \times 8}{32} = 4$ 个 32 位的整数。

### 第 2 小问

```c
for (I = 0; I < 8; I++)
    for (J = 0; J < 8000; J++)
        A[I][J] = B[I][0] + A[J][I]
```

首先我们需要列举出这段代码中的所有变量
* 外层循环变量 `I`
* 内层循环变量 `J`
* 数组 A 的基地址 `A`
* 数组 A 中的元素 `A[I][J]`
* 数组 A 中的元素 `A[J][I]`
* 数组 B 的基地址 `B`
* 数组 B 中的元素 `B[I][0]`

然后，注意到前一小问中告诉我们 1 个 cache 块可以存放 4 个 32 位整数。

由于题干中没有明确说明，因此我们假设数组 A 和 B 的元素均为 32 位整数。

结合时间局部性的定义可知，上述代码对以下变量/位置的访问均具有时间局部性特征
* 外层循环变量 `I`
* 内层循环变量 `J`
* 数组 A 的基地址 `A`
* 数组 B 的基地址 `B`
* 数组 B 中的元素 `B[I][0]`

变量 `I` 的时间局部性体现为
* 每次外层循环结束后的自增
* 每次到内存中访问 `A[I][J]` 等元素时，需要引用 `I` 计算该元素的地址

同理，变量 `J` 也具有时间局部性。

变量 `A` 的时间局部性体现为
* 每次到内存中访问 `A[I][J]` 等元素时，需要引用 `A` 计算该元素的地址

同理，变量 `B` 也具有时间局部性。

最后，考虑内层循环中的赋值语句
```c
A[I][J] = B[I][0] + A[J][I]
```
**注意，在内层循环中，变量 `I` 的值始终保持不变。**因此，每次计算 `A[I][J]` 的新值时都需要引用 B 中的同一个元素 `B[I][0]`，可见对该元素的访问也具有明显的时间局部性特征。

### 第 3 小问

由于
* 时间局部性关注的是对**相同**位置的访问
* 空间局部性关注的是对**相邻**位置的访问

因此二者是互斥的。

于是我们只需考虑如下的两个访问位置
* 数组 A 中的元素 `A[I][J]`
* 数组 A 中的元素 `A[J][I]`

实际上是两对**关系**
* 数组 A 中同一行的两个相邻元素 `A[I][J]` 和 `A[I][J+1]`
* 数组 A 中同一列的两个相邻元素 `A[J][I]` 和 `A[J+1][I]`

由于 C 语言采用**行优先**存储，即数组的同一行中的元素在内存中连续存放，因此对 `A[I][J]` 的访问显示出空间局部性。

### 第 4 小问

> [!NOTE]
> 本题题干表述不清，作答时言之成理即可。

```matlab
for I=1:8
    for J=1:8000
        A(I,J)=B(I,1)+A(J,I);
    end
end
```

既然题干说的是**矩阵**计算，因此我们假设数组 A
* 每一行的元素个数均相等
* 每一列的元素个数也相等

即不会出现锯齿状数组的情况。

由于
* 形如 `A(I,J)` 的所有元素中，地址最小的是 `A(1,1)`，地址最大的是 `A(8,8000)`
* 形如 `A(J,I)` 的所有元素中，地址最小的是 `A(1,1)`，地址最大的是 `A(8000,8)`
* 形如 `B(I,1)` 的所有元素中，地址最小的是 `B(1,1)`，地址最大的是 `B(8,1)`

因此
* 数组 A 至少需要有 8000 行和 8000 列。
* 数组 B 至少需要有 8 行和 1 列。

于是
* 数组 A 至少存放了 $8000 \times 8000 = 64,000,000$ 个整数，共需要 $\frac{64,000,000}{4} = 16,000,000$ 个 cache 块。
* 数组 B 至少存放了 $8 \times 1 = 8$ 个整数，共需要 $\frac{8}{4} 2$ 个 cache 块

因此一共需要 $16,000,002$ 个 cache 块。

### 第 5 小问

与第 2 小问相同。访问以下变量/位置时会显示出时间局部性：
* 外层循环变量 `I`
* 内层循环变量 `J`
* 数组 A 的基地址 `A`
* 数组 B 的基地址 `B`
* 数组 B 中的元素 `B[I][0]`

### 第 6 小问

由于 Matlab 采用**列优先**存储，因此与第 3 小问相反，显示出空间局部性特征的是 `A[J][I]`。

## 书后习题 5.10

### 第 1 小问

送分题。

* P1 的时钟频率等于 $\frac{1}{0.66} = 1.52$ GHz
* P2 的时钟频率等于 $\frac{1}{0.90} = 1.11$ GHz

### 第 2 小问

$$\text{AMAT} = \text{time for a hit} + \text{miss rate} \times \text{miss penalty}$$

从官方答案来看，需要沿用第 1 小问的假设，即 L1 cache 的命中时间等于 P1 和 P2 的时钟周期。

于是需要将访存时间换算成周期数
* 对 P1 来说，访问一次内存需要 $\lceil \frac{70}{0.66} \rceil= 107$ 个时钟周期
* 对 P2 来说，访问一次内存需要 $\lceil \frac{70}{0.90} \rceil= 78$ 个时钟周期

将已知信息代入公式得
* P1 的 AMAT 等于 $1 + 0.08 \times 107 = 9.56$ 个时钟周期，也就是 $9.56 \times 0.66 = 6.31$ ns
* P2 的 AMAT 等于 $1 + 0.06 \times 78 = 5.68$ 个时钟周期，也就是 $5.68 \times 0.90 = 5.11$ ns
