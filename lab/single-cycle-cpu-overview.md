# 单周期 CPU 架构

## 指令格式

```c
struct RTypeInstruction {
    int funct:6;  // 0,1,2,3,4,5
    int shamt:5;  // 6,7,8,9,10
    int rd:5;  // 11,12,13,14,15
    int rt:5;  // 16,17,18,19,20
    int rs:5;  // 21,22,23,24,25
    int opcode:6;  // 26,27,28,29,30,31
};
```

## 简单迭代法

### R 型指令的数据通路

由于需要先从寄存器堆中读出 rs 和 rt 的值，送入 ALU 进行计算后，再将结果写回寄存器堆的 rd 寄存器，思考寄存器堆的 timing methodology 应该是怎样的。

注意移位指令的第二个操作数不是 rt 而是 shamt，因此需要修改数据通路，将指令字的 shamt 传送到 ALU 的输入端。有 2 种实现方案：
* 利用 ALU 的 SrcB 输入端；对 ALUSrc 对应的多路选择器进行相应修改
* 修改 ALU 的封装，增加一个 shamt 输入端

> [!NOTE]
> 视频课中说方案 2 可以避免增加一个控点，因此推荐使用方案 2。但是我认为控点的增加是无法避免的，只不过是**在哪里**增加的问题，方案 2 需要在 ALU 内部增加一个控点。

### lw/sw 指令的数据通路

### beq/bne 指令的数据通路

注意实验课中 ALU 的封装与理论课稍有不同，具体来说是给 ALU 增加了一个 Equal 输出端而不是 Zero 输出端，因此，对 beq 指令的实现也有所不同。

### 其余 I 型指令的数据通路

### J 型指令的数据通路
