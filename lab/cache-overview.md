# 硬件 cache 机制设计实验

## 实验目的

* 掌握实现 cache 所需的 3 个关键技术
  * 数据查找
  * 地址映射
  * 替换算法
* 熟练使用 Logisim 的如下组件
  * 译码器
  * 多路选择器
  * 寄存器
  * 计数器
  * 三态缓冲器
  * 优先编码器
* 能够根据不同的映射策略在 Logisim 中实现相应的 cache 机制

## 实验要求

> [!IMPORTANT]
> 相关电路位于 [storage.circ](../extra/hustzc/storage.circ) 中。

* 设计实现一个具有 8 个槽的 cache
* 主存地址 16 位
* 块大小为 4 字节
* 可以采用
  * 直接相联 (direct mapping)
  * 全相联 (fully associative)
  * 2 路组相联 (2-way set-associative)
  * 4 路组相联 (4-way set-associative)

本实验中只要求设计一个只读的 cache，不需要处理一致性问题和写入逻辑。

块交换逻辑模块准备好一个数据块需要若干个时钟周期，这与实际 CPU 中的 cache 类似。

你不需要过多地关心块交换逻辑的内部实现。只需要了解，当 cache 模块发生缺失的时候，即 Miss 信号为 1 的时候，会出发块交换逻辑进行工作。经过若干个时钟周期后，会将数据块经过 BlkDIn 这样一条数据线将数据块传递给 cache，同时将块数据就绪信号 BlkReady 置为 1。

整个 cache 测试电路实际上是一个具有异步互锁特征的时序电路。

* [ ] 什么叫异步互锁

校验和最终结果应该是 32640

## 实验步骤

下面以全相联为例，介绍实验的具体步骤。

* 设计 cache 槽
* 设计查找逻辑：多路并发比较电路
* 设计读命中的处理逻辑
* 设计读缺失的处理逻辑
  * 涉及淘汰算法，相对而言比较复杂
    * 实验要求使用 LRU 算法，涉及计数器和归并比较电路的使用
  * 可以通过 Logisim 的优先编码器组件实现寻找空行的操作
* 设计块载入逻辑

不同 cache 映射机制下，cache 槽的设计会有一些明显的差异。你需要结合实际的情况进行合理的考虑。

缺省的 trace 是一个顺序访问的地址序列，命中率应该是 75%

完成 cache 的功能测试以后，大家可以将 trace 的访问序列替换为 trace 包中的其他 trace 数据来测试我们 cache 的实际性能。
